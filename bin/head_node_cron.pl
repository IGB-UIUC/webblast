#!/usr/bin/env perl
#Masterblast.pl
#This code manages the slavenodes, it decides whether
#a slave node should be running or shutdown.
#It also checks each slave node's PIDs to make sure that they didn't crash.
#When a job's progress matches a completed state,
#the job is finalized by concatinating the output into a single file.
#Conflicts are also resolved if found.
###################################################################################################

use DBI;
use Config::IniFiles;

#NEED TO CHANGE MANUALLY
############################
$configFilePath = "/home/a-m/blastweb/webblast.conf";
$slaveConfigFilePath = "/home/a-m/blastweb/webblast.conf";
#Load configuration from ini file
$cfg = new Config::IniFiles( -file => $configFilePath );

$sqlUser = $cfg->val('sql_config','sql_user');
$sqlPass = $cfg->val('sql_config','sql_pass');
$database = $cfg->val('sql_config','sql_database');
$sqlHost = $cfg->val('sql_config','sql_host');

$pathToSubmitScript = $cfg->val('scripts','slave_scripts');
$perlBin = $cfg->val('perl_bin','perl_bin_path');
$perlModule = $cfg->val('perl_bin','perl_module');
$qsubBin = $cfg->val('PBS_settings','qsub_bin_path');
$qstatBin = $cfg->val('PBS_settings','qstat_bin_path');
$pbsQueue= $cfg->val('PBS_settings','PBS_queue');
$pbsPriority= $cfg->val('PBS_settings','PBS_priority');

$resultsPath     = $cfg->val('head_paths','result_chunks_path');
$csvResultsPath  = $cfg->val('head_paths','csv_chunks_path');
$resultsDestPath = $cfg->val('head_paths','finalized_results_path');
$queryPath       = $cfg->val('head_paths','input_chunks_path');
$deletePath      = $cfg->val('head_paths','delete_path');
$perlScriptsPath = $cfg->val('head_paths','perl_scripts_path');
$PBSScriptPath = $cfg->val('head_paths','PBS_script_temp');
$updateDbScript = $cfg->val('head_paths','update_db_script');
$cpuCores = $cfg->val('node_settings','num_cpu_cores');

$slaveScript	 = $cfg->val('slave_paths','slave_script');

#Temporary submit script file generated by this script
$PBSTempScript = $PBSScriptPath."PBS_TempScript.sh";

#Static variables
#################
$statusSubmitted=6;
$statusNew=1;
$statusRunning=2;
$statusStopped=5;
$statusCompleted=3;
$statusFinalizing=8;
$statusDeleting=10;
$statusError=7;
$statusPause=11;
$statusCancel=4;
$commandStop=1;
$commandStart=2;

#Configuration variables
########################
$webURL;
$jobCompleteMsg;
$jobCompleteSubj;
$maxJobAge;
$fromEmail;

#Initialize the database connection
##############################################
$dbh= DBI->connect("DBI:mysql:".$database.":".$sqlHost,$sqlUser,$sqlPass,{RaiseError=>1});
$dbh->{mysql_auto_reconnect} = 1;

GetConfiguration();
FixConflicts ();
CheckRunningNodes();
CheckJobProgressIncramentConflicts();
$nodesRunning=GetRunningNodes();
print "Nodes running ".$nodesRunning."\n";
$schedule=GetScheduledNodes();
print "Nodes Schedule ".$schedule."\n";
CheckJobsCompleted();
ApplyNodeSchedule($schedule,$nodesRunning);
ApplyUpdates();
RemoveOldJobs();
FixBlastQueries();

#if the updatedb parameter was entered then update the databases
if($ARGV[0] eq 'updatedb')
{
	CheckRunningJobs();
}

#Close database connections
#############################################
$dbh->disconnect();

#Checks all nodes with running status are actually running
#If a node is not actually running the node status is changed to stopped and command to stop
###########################################################################################
sub CheckRunningNodes {
	#Get Running Nodes
	$queryRunningNodesInfo ="SELECT hostname,pid,id FROM nodes WHERE status=$statusRunning OR status=$statusSubmitted";
	$sth = $dbh->prepare($queryRunningNodesInfo);
	$sth->execute();
	while ( @runningNodesInfo = $sth->fetchrow_array() ) {
		#Check PID of running nodes
			#initiate a mysql connection to server
			print "Check process on ".$runningNodesInfo[0]." PID ".$runningNodesInfo[1]."\n";
			$exit = system($qstatBin." ".$runningNodesInfo[1]);

			if($exit==0)
			{
				#PID request was successful leave node info as is.
				print "node: $runningNodesInfo[2] \n";
			}else{
				#The PID returned nothing update nodes to stopped delete it
				$queryMarkNodeStopped="DELETE FROM nodes WHERE id=$runningNodesInfo[2]";
				$sthc=$dbh->prepare($queryMarkNodeStopped);
				$sthc->execute();

				print "Node # $runningNodesInfo[2] has failed, updating status.\n";
	
				#Cancel in progress queries for this node
				$queryCancelQueriesInProgress="UPDATE blast_queries SET statusid=$statusNew, reservenode=0, reservepid=0 WHERE reservenode=$runningNodesInfo[2] AND statusid=$statusRunning";
				print "\n".$queryCancelQueriesInProgress."\n";
				$sthc=$dbh->prepare($queryCancelQueriesInProgress);
				$sthc->execute();
				
				#clean up
				$sthc->finish();
			}
	}
}

#Gets the number of running nodes
###########################################
sub GetRunningNodes {
	print "\n\nCHECK NODES:";
	#Get Number of running nodes
	$queryCountRunningNodes ="SELECT COUNT(*) FROM nodes WHERE (status=$statusSubmitted OR status=$statusRunning) AND (commandid=$commandStart OR commandid=$commandStop)";
	$sth = $dbh->prepare($queryCountRunningNodes);
	$sth->execute();
	@nodesRunning = $sth->fetchrow_array();
	print "\nNodes submitted:";
	print `$qstatBin -u \$USER | grep \$USER | wc -l`;
	$nodesSubmitted = `$qstatBin -u \$USER | grep \$USER | wc -l`;
	return $nodesSubmitted;
}

#Gets the number of nodes that should be running now according to schedule
##########################################################################
sub GetScheduledNodes {
	#Get number of nodes to run from schedule
	$queryScheduledNodes =
	  "SELECT nodes,nodesmin FROM schedule WHERE date<=NOW() ORDER BY date DESC LIMIT 1";
	$sth = $dbh->prepare($queryScheduledNodes);
	$sth->execute();
	@schedule = $sth->fetchrow_array();
	$sth->finish();

	$queryChunksLeft = "SELECT CEILING(SUM((queriesadded-queriescompleted)/chunksize)) as totalchunks FROM blast_jobs WHERE status=1";
	$sth = $dbh->prepare($queryChunksLeft);
        $sth->execute();
        @chunksLeft = $sth->fetchrow_array();
        $sth->finish();
	$nodesNeeded = @chunksLeft[0]/$cpuCores;
	$nodesNeeded = ($nodesNeeded == int($nodesNeeded)) ? $nodesNeeded : int($nodesNeeded + 1);
	print "Nodes needed ".$nodesNeeded."\n";

	if($nodesNeeded > $schedule[0])
	{
		return $schedule[0];
	}	

	if($nodesNeeded < $schedule[0])
	{
		if($nodesNeeded > $schedule[1])
		{
			return $nodesNeeded;
		}
		return $schedule[1];
	}
	
	return $schedule[0];
}

#Gets the configuration variables from the database
###################################################
sub GetConfiguration {
	$queryConfigPaths ="SELECT url, jobcompletemsg, jobcompletesubj, maxjobage, fromemail FROM config ORDER BY id DESC LIMIT 1";
	$sth = $dbh->prepare($queryConfigPaths);
	$sth->execute();
	@configPaths    = $sth->fetchrow_array();
	$sth->finish();
	$webURL          = $configPaths[0];
	$jobCompleteMsg  = $configPaths[1];
	$jobCompleteSubj = $configPaths[2];
	$maxJobAge 	 = $configPaths[3];
	$fromEmail	 = $configPaths[4];	
	
}

#Check whether a job has completed
#if the job is completed it begins the concatination process.
#Checks whether any concatination processes have completed and send an email to the user if completed.
#######################################################################################################
sub CheckJobsCompleted {
	#Check jobs completed
	$queryNewJobs ="SELECT j.id,j.queriescompleted,j.queriesadded,j.submitpid,u.netid, j.status, u.email,j.token FROM blast_jobs j, users u WHERE (j.status=$statusNew OR j.status=$statusFinalizing) AND u.id=j.userid";
	print $queryNewJobs."\n";
	$sthj = $dbh->prepare($queryNewJobs);
	$sthj->execute();

	while ( @jobsArray = $sthj->fetchrow_array() ) {
		$processStatus = `ps -ef | grep " $jobsArray[3] " | grep -v grep`;
		print "Jobs IDs:".$jobsArray[0]."\n";
		if ($processStatus) {
			print "Job submitting ID ".$jobsArray[0].":".$processStatus."\n";
			#do nothing job is still being submitted
		}
		else {
			if ($jobsArray[1] == $jobsArray[2]) {
				print "completed job found id=$jobsArray[0]";
				if ( $jobsArray[5] == $statusNew ) {

					#Mark job as finalizing
					$querySetJobToCompleted ="UPDATE blast_jobs SET status=$statusFinalizing WHERE id=$jobsArray[0]";
					$sth = $dbh->prepare($querySetJobToCompleted);
					$sth->execute();

					#Concatinate results and store file in destination path
					system( "nice ".$perlBin." "
						  . $perlScriptsPath
						  . "concat.pl "
						  . $jobsArray[0] . " "
						  . $jobsArray[4] . " "
						  . $resultsPath . " "
						  . $resultsDestPath
						  . " result"
						  . " "
						  . $configFilePath
						  . " &" );
					print "nice ".$perlBin." "
                                                  . $perlScriptsPath
                                                  . "concat.pl "
                                                  . $jobsArray[0] . " "
                                                  . $jobsArray[4] . " "
                                                  . $resultsPath . " "
                                                  . $resultsDestPath
                                                  . " result"
                                                  . " "
						  . $configFilePath
                                                  . " &";
					$error =
					  system( "nice ".$perlBin." "
						  . $perlScriptsPath
						  . "concat.pl "
						  . $jobsArray[0] . " "
						  . $jobsArray[4] . " "
						  . $csvResultsPath . " "
						  . $resultsDestPath
						  . " csv" 
						  . " "
						  . $configFilePath
                                                  . " &" );
					print $error;

					#give concat.pl script time to update job status
					sleep 3;
				}

	   			#Check if the concatination process is done before sending user an e-mail
				$queryConcatStatus ="SELECT concatpidresult,concatpidcsv FROM blast_jobs WHERE id="
				  . $jobsArray[0];
				$sth = $dbh->prepare($queryConcatStatus);
				$sth->execute();

				@concatStatusArray = $sth->fetchrow_array();
				system("ps $concatStatusArray[1]");
				print "\nChecking concat status:".$?;
				if ( $? != 0 ) {
					system("ps $concatStatusArray[0]");
					if ( $? != 0 ) {
						#Mark job as completed
						$querySetJobToCompleted ="UPDATE blast_jobs SET status=$statusCompleted, concatpidresult=0, concatpidcsv=0, completeDate=NOW() WHERE id=$jobsArray[0]";
						$sth = $dbh->prepare($querySetJobToCompleted);
						$sth->execute();

						#check if any errors occured in any of the queries
						$queryFailedQueries = "SELECT COUNT(*) FROM blast_queries WHERE jobid=".$jobsArray[0]." AND statusid=".$statusError;
						$sth = $dbh->prepare($queryFailedQueries);
						$sth->execute();
						@failedQueries = $sth->fetchrow_array();
						print "\nfailed queries ".$failedQueries[0];	
						$updatedJobCompleteMsg  = $jobCompleteMsg;
						$updatedJobCompleteSubj = $jobCompleteSubj;

						$jobReplace = $jobsArray[0];
						$updatedJobCompleteSubj =~ s/\[job\]/$jobReplace/g;
						$updatedJobCompleteMsg  =~ s/\[job\]/$jobReplace/g;

						$csvWeburl = $webURL
						  . "download.php?job="
						  . $jobsArray[0]
						  . "&filetype=csv"
						  . "&token="
						  . $jobsArray[7];
						$resultWeburl = $webURL
						  . "download.php?job="
						  . $jobsArray[0]
						  . "&filetype=result"
						  . "&token="
                                                  . $jobsArray[7];
						$errorsWeburl = $webURL
						  . "index.php?job="
						  . $jobsArray[0]
 			                          . "&view=queries"
						  . "&show=errors";
						
						$updatedJobCompleteMsg =~ s/\[url\]/$webURL/g;
						$updatedJobCompleteMsg =~ s/\[csvurl\]/$csvWeburl/g;
						$updatedJobCompleteMsg =~ s/\[resulturl\]/$resultWeburl/g;
						$updatedJobCompleteMsg =~ s/\[num_errors\]/$failedQueries[0]/g;
						$updatedJobCompleteMsg =~ s/\[errors_url\]/$errorsWeburl/g;


						#send user an email informing him of job completion
						$sendmail = "/usr/sbin/sendmail -t";
						$from     = "From: ".$fromEmail."\n";
						$subject = "Subject: " . $updatedJobCompleteSubj . "\n";
						$content = $updatedJobCompleteMsg;
						$to = "To: " . $jobsArray[6] . "\n";

						open( SENDMAIL, "|$sendmail" )
						  or die "Cannot open $sendmail: $!";
						print SENDMAIL $from;
						print SENDMAIL $to;
						print SENDMAIL $subject;
						print SENDMAIL $content;
						close(SENDMAIL);
					}
				}
			}
		}
	}
	$sth->finish();
}

#Applies the schedule so nodes are shutdown or started according to schedule
############################################################################
sub ApplyNodeSchedule {
	my $schedule = shift;
	my $nodesRunning = shift;
	
	#Add or remove nodes depending on schedule
	if ( $schedule < $nodesRunning ) {

		#Stop nodes
		$nodesToStop = $nodesRunning - $schedule;
		print "\nStopping $nodesToStop nodes";
		$queryStopNodes ="UPDATE nodes SET commandid=$commandStop WHERE status=$statusRunning OR status=$statusSubmitted ORDER BY status DESC LIMIT $nodesToStop";
		$sth = $dbh->prepare($queryStopNodes);
		$sth->execute();

	}
	elsif ( $schedule > $nodesRunning ) {

		#start nodes
		GenerateSubmitScript();

		$nodesToStart = $schedule - $nodesRunning;
		for($countNodes=1; $countNodes<=$nodesToStart; $countNodes++) 
		{
			#Submit PBS job
			$queryInsertNodes = "INSERT INTO nodes (status,processes,pid,commandid)VALUES(".$statusSubmitted.",0,0,2)";
			$sth = $dbh->prepare($queryInsertNodes);
			$sth->execute();
			$nodeNumber=$dbh->last_insert_id(undef, undef, undef, undef);
			print $qsubBin." -v BLAST_NODE_ID=".$nodeNumber." ".$PBSTempScript;
			system($qsubBin." -v BLAST_NODE_ID=".$nodeNumber." ".$PBSTempScript);
			print $qsubBin." ".$PBSTempScript;
		}
	}
	$sth->finish();
}

#Fixes conflicts between node status and commands
#######################################################
sub FixConflicts {
	#Fix conflicts
	$queryNodesConflicts ="UPDATE nodes SET commandid=$commandStop WHERE status=$statusStopped";
	$sth = $dbh->prepare($queryNodesConflicts);
	$sth->execute();
}

#Checks that the job progress displayed is the actual job progress
##################################################################
sub CheckJobProgressIncramentConflicts {
	print "\n\nUPDATE JOBS PROGRESS:";
	#Check for job progress incrament conflicts
	$queryCountCompleteFailed ="SELECT j.id FROM blast_jobs j WHERE j.status=1";
	#AND ((SELECT COUNT(statusid) FROM blast_queries WHERE jobid=j.id AND (statusid=1 OR statusid=4 OR statusid=2))=0 OR j.queriescompleted>j.queriesadded)";
	$sth = $dbh->prepare($queryCountCompleteFailed);
	$sth->execute();
	while ( @failedJobComplete = $sth->fetchrow_array() ) {
		print "\nUpdating job progress: Job (".$failedJobComplete[0].")";
		$queryUpdateJobProgress = "UPDATE blast_jobs SET queriescompleted=(SELECT SUM(chunksize) FROM blast_queries WHERE jobid="
		  . $failedJobComplete[0]." AND (statusid=".$statusCompleted." OR statusid=".$statusError." OR statusid=".$statusCancel.")"
		  . "), queriesadded=(SELECT SUM(chunksize) FROM blast_queries WHERE jobid="
                  . $failedJobComplete[0]
                  . ") WHERE id="
		  . $failedJobComplete[0];
		print $queryUpdateJobProgress;
		$sthj = $dbh->prepare($queryUpdateJobProgress);
		$sthj->execute();
	}
}

#fix failed blast queries
#if blast query is still marked as running and reserved node
#is not longer running then reset blastq query to new so it may
#run on a currently running node
########################
sub FixBlastQueries {
	$queryFailedQueries = "SELECT blast_queries.id FROM blast_queries LEFT JOIN nodes ON blast_queries.reservenode=nodes.id WHERE statusid=".$statusRunning." AND nodes.id IS NULL";
	$sth = $dbh->prepare($queryFailedQueries);	
	$sth->execute();
	while( @failedQueries = $sth->fetchrow_array())
	{
		print "\nFound failed queries (".$failedQueries[0].")";
		$queryResetFailedQueries = "UPDATE blast_queries SET statusid=".$statusNew.", reservenode=0,reservepid=0 WHERE id=".$failedQueries[0];
		$sthr = $dbh->prepare($queryResetFailedQueries);
		$sthr->execute();
	}

}

#Removes oldest expired job
#############################

sub RemoveOldJobs
{
	#Get all jobs older than maxJobAge
	$queryOldJobs = "SELECT j.id, u.netid FROM blast_jobs j, users u WHERE TIMESTAMPDIFF(DAY,j.completeDate,NOW())>".$maxJobAge." AND j.status=3 AND u.id=j.userid LIMIT 1";	
	$sth = $dbh->prepare($queryOldJobs);
	$sth->execute();
	@oldJob = $sth->fetchrow_array();
	if(@oldJob)
	{
		print "\nDeleting job number: ".$oldJob[0];
		$queryUpdateJobStatus = "UPDATE blast_jobs SET status=".$statusDeleting." WHERE id=".$oldJob[0];
		print "\n".$queryUpdateJobStatus;
		$sth->finish();
		$sthj = $dbh->prepare($queryUpdateJobStatus);
		$sthj->execute();
		DeleteFolder($resultsPath.$oldJob[0],$deletePath,$oldJob[0],0,"results");
		DeleteFolder($queryPath.$oldJob[0],$deletePath,$oldJob[0],0,"query");
		DeleteFolder($csvResultsPath.$oldJob[0],$deletePath,$oldJob[0],0,"csv");
		DeleteFile($resultsDestPath,$oldJob[1]."_".$oldJob[0].".csv");
		DeleteFile($resultsDestPath,$oldJob[1]."_".$oldJob[0].".result");	
		DeleteJob($oldJob[0]);
	}
	
	
}

sub DeleteFolder
{
	my $folderForDeletion = shift;
	my $deletionFolder = shift;
	my $jobid = shift;
	my $mkdir = shift;
	my $type = shift;

	system("mv ".$folderForDeletion." ".$deletionFolder.$jobid."_".$type);
	print "\nmv ".$folderForDeletion." ".$deletionFolder.$jobid."_".$type;
	if($mkdir)
	{
	        system("mkdir $folderForDeletion");
	        system("chmod -R 2777 $folderForDeletion");
	}
	system("rm -rf ".$deletionFolder.$jobid."_".$type);
	print "\nrm -rf ".$deletionFolder.$jobid."_".$type;
}

sub DeleteJob
{
	my $jobid = shift;

	$rowsAffected=1;
	print "starting loop";
	while($rowsAffected > 0)
	{
	        $queryDeleteQueries="DELETE FROM blast_queries WHERE jobid=".$jobid." LIMIT 2000";
	        $sth = $dbh->prepare($queryDeleteQueries);
	        $rowsAffected = $sth->execute();
	        sleep 2;
	}

}

sub DeleteFile
{
	my $dir = shift;
	my $filename = shift;
	system("rm -f ".$dir.$filename);
	print "\nrm -f ".$dir.$filename;
}

#Apply updated databases on slave nodes
########################################

sub ApplyUpdates
{
	$queryUpdates = "SELECT id, updatedate FROM dbupdates WHERE updatestatus=".$statusNew." ORDER BY id DESC LIMIT 1";
	$sth = $dbh->prepare($queryUpdates);
	$sth->execute();
	@updates = $sth->fetchrow_array();
	if(@updates)
	{
		print "Database Update is ready ".$updates[1]."\n";
	}
	$sth->finish();
}

sub GenerateSubmitScript
{	
	open(PBS_SCRIPT, ">".$PBSTempScript);
	print PBS_SCRIPT "#!/bin/bash\n";
	print PBS_SCRIPT "##SCRIPT GENERATED BY WEBBLAST CRON HEAD\n";
	#print PBS_SCRIPT "#PBS -l nodes=1:ppn=8\n";
	print PBS_SCRIPT "#PBS -l ncpus=8,mem=16462668kb\n";
	print PBS_SCRIPT "#PBS -q ".$pbsQueue."\n";
	print PBS_SCRIPT "#PBS -p ".$pbsPriority."\n";
	#print PBS_SCRIPT "module load perl\n";
	#print PBS_SCRIPT "module load blast\n";
	print PBS_SCRIPT "module load ".$perlModule."\n";
	print PBS_SCRIPT $perlBin." ".$slaveScript." ";
	print PBS_SCRIPT $slaveConfigFilePath."\n"; 
	close(PBS_SCRIPT);		
}

#Check if any jobs are running
# if no jobs ar erunning then update databases
sub CheckRunningJobs
{
	$queryRunningJobs = "SELECT status, id FROM blast_jobs WHERE status=".$statusNew." LIMIT 1";
        $sth = $dbh->prepare($queryRunningJobs);
        $sth->execute();
        @runningJobs = $sth->fetchrow_array();
        if(@runningJobs)
        {
                print "Jobs are running ".$runningJobs[1]."\n";
		
        }
	else
	{
		
		print "Updating latest folder ".$updateDbScript." \n";
		$exit = system($updateDbScript);
		if($? == -1)
		{
			print "Failed to update databases";
		}
		else
		{
			MarkDbUpdate();
			print "Successfully updated databases";
		}
	}
        $sth->finish();
}

#update the date for the last database update
sub MarkDbUpdate
{
	$queryUpdateDate = "INSERT INTO dbupdates (updatestatus,updatedate)VALUES(3,NOW())";
        $sth = $dbh->prepare($queryUpdateDate);
        $sth->execute();
	$queryUpdateDateNcbiDb = "UPDATE dbs SET last_update=NOW() WHERE userid=0";
        $sth = $dbh->prepare($queryUpdateDateNcbiDb);
        $sth->execute();
}
